---
layout: post
title: 第九章操作系统笔记
tags: [Learning]
---
# 第四部分 调度
- 单处理器调度
- 多处理器和实时调度

# 第九章 单处理器调度

## 处理器调度的类型
- 长程调度：
	- 决定哪些新建进程可以进入系统准备执行
	- 控制多道程序系统的并发程度
	- 进程越多则各进程对CPU的使用百分比越小
	- 次数最少
- 中程调度：
	- 决定交换哪些主存-辅存进程
	- 基于多道程序设计的管理需要
- 短程调度：
	- 决定下一个使用CPU的进程
	- 次数最多
- I/O调度（不是处理器调度）

### 调度与进程状态转换
短程：运行\<-\>就绪\<-\>阻塞
中程：\<-\>阻塞/挂起\<-\>就绪/挂起\<-\>
长程：\<-\>新建\<-\>退出\<-\>

#### 层次图、调度队列图（PPT 4）

### 短程调度
#### 短程调度时机
- 当前进程正常或异常终止（中断）
- 时钟或I/O中断
- 系统调用（软中断）
- 信号量操作（软中断）

#### 短程调度模式
##### 非剥夺式（nonpreemptive）
- 让进程运行直到结束或阻塞的调度方式
- 容易实现
- 适合专用系统（不需要并发的系统），不适合通用系统

##### 剥夺式（preemptive）
- 允许将逻辑上可继续运行的进程在运行过程中暂停的调度方式
- 可防止单一进程长时间独占CPU
- 系统开销大：需要硬件实现进程上下文切换

##### 进程上下文切换基本过程
- 保存现场
- 根据某种调度算法选择下一个要运行的进程
	- 如果没有就绪进程，系统会安排一个空闲进程，没有其他进程时该进程一直运行，
	- 在执行过程中可接受中断
- 恢复现场

##### 短程调度目标
- 面向用户（主要目的）、面向系统（辅助）的目标
- 定量与定性目标
- 主要的目标：
	- 公平：每个进程合理获得CPU份额
	- 效率：使CPU和其他系统资源尽量忙绿
	- 响应时间（从提交到开始输出结果）：尽可能短
		- 交互式系统中尤为重要（非交互例子：大数据计算系统，几天后才有结果）
	- 周转时间（驻留时间）（从提交 到结束）尽可能短
	- 吞吐量（单位时间内完成的进程数）尽可能大
	- 实时性：可以指定进程完成的最后期限

## 进程调度算法

### 各种调度策略及特点
- 先来先服务（FCFS）
- 时间片轮转（RR）
- 最短进程优先（SPN）
- 最短剩余优先（SRT）
- 最高相应比优先（HRRN）
- 虚拟轮转（VRR）
- 多级队列反馈（MF/FB）
	- 其他队列：最高优先级优先（HPF）
	- 最低队列：轮转


### 先来先服务（FCFS）
- 非剥夺式
- 短进程等待的时间可能非常长
- I/O密集进程必须等待CPU密集进程结束

### 最短进程优先（SPN）（PPT不够详细，289页）（N for next）
- 选取估计运行时间最短的进程
- 不可剥夺式（不适合分时和事务处理系统）
- “长”进程可能饿死
- 难点：估计进程的执行时间
	- 生产环境（ATM）：统计
	- 交互式环境（PC机）：估计
		- 进程执行时间的估计：“指数平滑”技术
			- *估计公式*
				1. 以前的实例执行时间测量值平均值（不能反映实时变化）
				2. Sn+1 = 1/nTn + (n-1)/nSn
				3. Sn+1 = aTn + (1-a)Sn（指数平均法）（指数平滑技术）
					- a：加权系数：a值越大，对变化反应越快
				4. Sn+1 = aTn + (1-a)Tn-1 + ...+(1-a)^iTn-i + ... + (1-a)^nS1

### 最短剩余优先（SRT）
- 剥夺式的SPN
	- 新进程进入就绪队列时将引发重新调度
	- 选取估计剩余时间最短的那个进程
- 需要估计进程剩余执行时间
- 长进程可能饿死

### 最高响应比优先（HRRN）
- 非剥夺式
- 每次调度选取响应比R最大的按个进程（R= （w+s）/s）
	- w：等待CPU时间
	- s：估计执行时间
- 偏向于短进程，但长进程也不会饿死，因为等待时间越久R越大
- 和最短进程优先的关系：最短进程优先的计算公式是 1/s 
- 同SPN、SRT，需要估计时间

### 时间片轮转（RR）
- 剥夺式的FCFS
	- 把CPU划分若干时间片，按照顺序分配给就绪队列中的各个进程
	- 时间片太短：切换开销大
	- 太长：响应时间变长
- 分时系统和事务处理系统中常用时间片轮转法
- 利于CPU密集进程，不利于I/O密集进程

### 虚拟轮转（VRR）
- 阻塞解除（I/O事件结束）的进程进入辅助队列
- 辅助队列中的进程比就绪队列优先获得处理器
- 解决问题：轮转对I/O密集型进程不公平性的问题：每需要一次IO，就要重新排一次队

### 最高优先级优先（HPF）
- 每个进程被赋予一个优先级
- 优先级确定方法：
	- 静态：进程创建时指定优先级，运行时优先级不变
	- 动态：进程创建时指定一个优先级，但在其生命周期内优先级可以动态变化
		- 举例：等待时间长的优先级可以提高
		- 时间片过后的优先级可降低
	- 实现时可对应不同优先级采用多个就绪队列
- 缺点：系统负担大，需要监控每个进程的运行情况

### 多级队列反馈（MF/FB）
- 剥夺式、时间片
- 关注进程已执行时间，不估计剩余执行时间
- 思想：动态优先级机制
	- 设立多个优先级就绪队列、各个队列时间片不同（优先级越高时间片越小）
	- 新的就绪进程进入最高优先级队列
	- 进程由于时间片用完被抢占而放弃CPU，下降一个优先级队列（最高-\>最低）
	- 进程由于等待而放弃CPU后，进入等待队列，一旦等待的事件发生，则回到原来的就绪队列。
	- 在各优先级队列中采用FCFS（最低级队列中采用RR）

### 性能比较
- 周转时间：即驻留时间：即系统时间+等待时间+执行时间
- 响应时间：
- 归一化周转时间 = Tr/Ts —— 周转时间/服务时间
- PPT 28：曲线越往下，性能越好（书上图横纵坐标反了）
- 先来先服务的等待时间是常数。

## 公平共享调度
- 用户关心的是应用或作业的整体性能，因此应该基于进程集合进行调度策略。
- 同一用户组的用户应该只影响本用户组的调度而不影响其他用户组的调度，应基于用户组进行调度策略
- 公平共享调度：基于组调度，每个组公平共享CPU时间
	- 每个用户被指定某种类型的权值，以定义其使用共享资源的份额

### 公平调度实例

## 传统Unix调度策略
- 分时交互系统
- 多级队列反馈、每个优先级队列使用RR
- 优先级一秒重新计算一次
- 优先级基于进程类型和执行历史

### 传统Unix的进程调度

### 用户优先级（相对于核心态的优先级）