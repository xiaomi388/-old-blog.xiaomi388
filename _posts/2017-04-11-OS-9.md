---
layout: post
title: 第九、十、十一周操作系统笔记
tags: [Learning]
---

## 第九周

## 第七章 内存管理
- 存储管理的要求
- 分区存储
- 分页存储
- 分段存储

### 存储管理
- 主要工作：将程序载入内存，让CPU执行
- 目的：
	- 多道程序设计（将内存划分多个区域容纳多个进程）
	- 有效分配内存以容纳尽量多的进程
- 关键词
	- 重定位
	- 保护
	- 共享
	- 逻辑组织
	- 物理组织
#### 重定位
1.  逻辑地址/相对地址
	- 逻辑地址：与内存内容无关的内存位置
	- 相对地址：相对于某一点的逻辑地址（程序起始位置、段地址、偏移地址）
2. 物理地址/绝对地址
	- 物理地址：内存的实际地址，也称为绝对地址
3. 重定位
	- 程序员不知道程序在运行时在内存所处的位置
	- 处于内存某一块区域的代码在运行中被换出(swap out)外存又被交换进内存后会被交换进(swap in)到另外一块区域
	- 重定位一般要求硬件支持

#### 保护
- 多道程序和共享内存技术：
- 一个进程不能对其他进程进行非授权访问

#### 共享
- 支持不同进程访问内存同一区域
- 距离
	- 共享程序区
	- 合作进程间共享某些数据结构
- 重定位机制通常也支持共享

#### 逻辑组织
- 主存、辅存是一堆线性结构的
- 模块化形式组织用户程序和数据
	- 模块化有利于设计期间的编程
	- 模块化有利于运行时刻的保护
	- 模块化有利于运行时刻的共享
- 分段存储管理技术最符合程序员组织程序的观点

#### 物理组织
- 主存与辅存间的信息交换能更好地实现系统目标
- 程序员不需要关心物理组织
- 物理组织是操作系统的责任

#### 覆盖技术和交换技术
- 多道环境下扩充内存的方法
- 覆盖技术主要用在早其的操作系统中
- 交换技术广泛用于小型分时系统，交换技术的发展导致了虚存技术的出现
- 共同点：
	- 进程的程序和数据放在外存
	- 只有当前需要执行的部分才放在内存
	- 内外存之间进行信息交换

##### 覆盖技术
- 把程序划分为若干个相对独立的程序段，不会同时执行的程序段共享同一块内存区域。
- 程序员要向系统提供覆盖结构，操作系统完成程序段的覆盖
- （简单来说：不需要把整个程序载入到内存中，用哪段载入哪段即可）

## 第十周
##### 交换技术
- 内存空间紧张时
	- 将内存中某些进程暂时swap out，外存中进程swap in
	- 交换技术其实是进程在内存和外存之间的动态调度。

##### 交换技术与覆盖技术比较
- 交换技术不需要用户给出程序段之间的逻辑覆盖结构
- 交换发生在不同的进程或者作业
- 覆盖发生在统一进程或者作业
- 覆盖只能覆盖那些与覆盖段无关的程序段

#### 分区存储管理技术
- 分区：
	- 固定分区、动态分区
	- 特殊场合才使用（如内核存储管理）
	- 在一些已经过时的操作系统采用
- 简单内存分页（不单独使用）
	- 大小相等，需一次装入一个进程的所有页
- 简单进程分段（不单独使用）
	- 需一次装入一个进程的所有段
- 虚拟内存分页
	- 不许一次装入一进程的所有页
- 虚拟内存分段
	- 不需一次装入一进程的所有段

##### 固定分区
- 等长、不等长
- 等长分区问题：进程\>分区大小的话，则只能利用覆盖技术放置。
- 不等长放置算法：
	- 多队列：每个分区都有一个队列。
	- 单队列：单一队列，使用可容纳它的最小空闲分区，无可用分区时则使用交换技术
- 优缺点：
	- 相对简单、开销小
	- 分区数目预设，限制了活动进程数
	- 大小预设，小作业不能充分利用其占有空间（内碎片）

##### 动态分区
- 分区数目和大小可改变
- 问题：外碎片（进程与进程间有空隙）
- 消除碎片：移动进程使其相互紧靠（相当耗时）

###### 动态分区的放置算法
- 首次适配（找到第一个合适的外碎片）（简单最好最快）
- 最佳适配（问题：带来更多的碎片）（通常最差）(类似贪心算法)
- 下次适配（从上一次分配块的位置开始搜寻）

##### 伙伴系统
- 固定分区利用率低，动态分区维护复杂
- 折中方案：伙伴系统（p226）
	- 可用内存块的大小为2^k （L\<=K\<=U)
	- 最小块大小2^L
	- 最大块2^U
- 相当于二叉树的数据结构

##### 分区管理中的重定位
- 简单重定位
	- 多队列的不等长固定分区
	- 只需要在进程第一次载入时把其中的内存引用全换成绝对地址
- 动态重定位
	- 等长固定分区
	- 单队列的不等长固定分区
	- 动态分区
	- “压缩”后

#### 页式存储管理
- 分页原理
	- 将主存划分为许多等长的小帧
	- 将进程划分成若干页（page），一页的大小=一帧的大小
- 采用分页技术，进程的数据无需连续。

##### 页表
- 每个进程建立、维护一个页表
- 每个表项包含该页在内存中对应的帧号（还有保护、共享信息）
- 页表以页号为索引
- OS还维护一个空闲帧的列表（帧是位于物理地址上的）

##### 简单分页中的重定位（PPT 34页 必看）
- 程序逻辑地址由两部分组成（对应cache的段号和段内偏移）
	- 页号
	- 页内偏移
- CPU的一堆寄存器记录当前的页表起始物理地址、页表长度
- （页号、偏移） -\> （帧号，偏移）
- 规定：页（帧）的大小必须为2的整数m次幂。（方便某些算法的性质）
- 当页的大小为2的m次幂时，逻辑地址=相对地址

###### 简单分页特点
优点：
- 分页中页帧很小，内部碎片小
- 分页中一个进程可以占用多个页帧，不需要覆盖
- 不要求占用的多个页帧连续
问题：
- 不易实现共享和保护
- 不便于动态链接
- 不易处理数据结构和动态增长

#### 分段存储管理
- 将程序数据划分成若干段，不要求等长，但不能超过最大长度
- 进程加载时，所有段被载入内存可用区域（不用连续），同时建立段表

##### 段表

##### 简单分段的重定位（PPT 39 页）
- 逻辑地址-\>物理地址：
	- 段号-\>查询段表-\>获取段基址（段起始地址）（16位），同时查询段长并比较段长和段偏移地址大小，若\<，则报错。
	- 物理地址 = 段起始地址 + 偏移

#### 页式管理和段式管理的比较
\- 
	- 分页：系统管理需要
	- 分段：用户应用需要
	- 距离：一条指令或者一个操作数可能会跨越两个页的分界处，而不会跨越两个段的分界处
	- 页大小固定，段不固定
\- 
	- 分页是一维的，一个指针既可。
	- 分段是二维的，需要两个指针。
\- 
	- 通常段表比页表短，因为段比页大

#### 分页和分段的主要优缺点
- 分段克服了分页的问题
- 分页利用率比分段高

作业：P235 7.8.2 复习题 7.6 7.8
   P7.8.3 习题  7.8 7.13（选做）

## 第八章 虚拟存储

### 虚拟存储的关键基础
- 页式\段式两特点
	- 动态地址转换：进程可被交换出/入内存，前后内存位置可以不同
	- 不连续分配
- 部分加载
	- 运行时进程所有页段不必都在内存里，只要下一条要执行的指令和下一个要访问的数据在即可。

### 部分加载方式与程序的执行
- OS仅把程序起始点的一个或几个块装进内存
- 页表/段表表项中有一个二进制指示对应的块是否在内存中，进程中驻留在内存的部分称为驻留集。
- *若遇到一个逻辑地址访问不在内存中的块，则产生一个访问内存错误的中断。*
- OS响应中断时将进程置于阻塞态，并将逻辑地址访问的块读入内存：过程如下：
	- 发出一个磁盘I/O请求
	- 在执行I/O操作期间，分派另外一个进程运行
	- 磁盘I/O完成时产生中断，OS把受影响进程加入就绪队列

### 部分加载好处
- 内存可容纳更多进程
- 进程可比内存大
	- 用户程序可以使用独立于物理内存的逻辑地址单元组成存储空间（虚拟存储）
	- 逻辑地址空间可以比物理地址空间大：物理地址16位，而逻辑地址可以是28位

### 虚拟存储技术特征
- 不连续性：物理内存分配不连续
- 部分交换（思考：与交换技术的区别？）
- 大空间

### 虚拟存储硬件（PPT 7）
- MMU：存储管理单元

### 程序局部性与虚拟存储
- 局部性原理：在一段时间内置运行某一段程序/访问某一块数据区
	- 空间局部性：访问地址
	- 时间局部性：模块调用
- 局部性原理为虚拟存储提供了好处；若没有局部性，则虚拟存储的时间和一次加入是一样的。

### 虚拟存储的要求与抖动问题

#### 虚拟存储管理要求
- 为了容纳更多进程，每个进程只有一小部分在内存中
- 内存满时 OS 若要调入新的块，则必须要把内存中的某一块换出去
- OS必须在新的块要使用到之前就换入他

#### 抖动（thrashing）问题
- 交换操作过于频繁，如将要用到的页式刚刚才被换出去的，导致CPU更多的时间是在处理交换而不是在执行指令。

#### 局部性原理保证了虚拟存储系统的可行性和效率性
- 内存可以容纳更多进程
- 可以避免由于交换（in/out）进程不使用的部分而造成的时间浪费
- 可以有效避免抖动：根据最近的历史记录猜测哪些块最近最不可能使用到。

### 虚拟存储必要的支持

#### 硬件支持
- 内存管理硬件必须要支持分页/分段所需的动态地址转换

#### 软件支持
- OS必须管理内存和外存之间的页/段/段&页的交换
- 调页策略、放置策略、替换策略
- 驻留集合工作集管理
- 清除（回写）策略、加载（并发度）控制

### 虚拟分页（PPT 12）

#### 页表
页表项的一般内容：
- P（Present）：在/不在内存
- M（Modified）：有没有被修改
- Protection：保护码，1位或多位
- Referenced：有没有被访问
- C（Cache）：是否禁止缓存

### 页表与虚拟存储
- 页表可能会非常大，从而占用内存也非常大
- 通常也对页表进行分页，存储到虚拟内存里
- 进程运行时，它的部分页表必须在内存里（包括正在使用的页面所对应的表项）
- 多级页表
	- 若采用二级页表（32位x86CPU），则虚页号被划分为两个域：PT1和PT2
	- 顶级页表（内存中）以PT1位索引，其表项指向二级页表，二级页表以PT2为索引
	- 除顶级页表外的其他页表可以在内外存转换
	- 64位处理器使用三级页表
	- 二级页表的地址转换原理（PPT 19）

### 倒排页表
- 实际内存的每个页帧对应一个页表项

### 使用TLB（检测缓冲区）的地址转换

#### 缺页率
- 缺页次数/内存访问次数

#### 页面大小会影响缺页率
- 页面小：每个进程内存页多，调页很快适应局部性原理的要求，缺页率低
- 页面大：进程大部分地址空间都在内存，缺页率低。
- 页面中等大小：局部性区域只占每页的较小部分，缺页率高

##### 缺页率与页面大小、软件策略（29）

### 虚拟段式存储管理 
- 优点
	- 简化动态增长的数据结构的处理
	- 支持模块的独立修改和重编译
	- 更有效的进程共享
	- 更容易实现保护
- 虚拟段式存储管理的组织
	- 段表：有表项组成，每个进程一张
	- 段表长度不定，存放在内存
	- 当前进程的段表起始地址保存在CPU的一个专用寄存器里
	- 进程中有的段可能不在内存中。

### 虚拟段页式存储管理
- 基本原理
	- 将程序按逻辑结构划分为若干段，每个段进一步划分为若干个页
	- 将内存划分成许多小的帧，帧与页大小相等
	- OS为每个进程建立并维护一个段表，为每个段建立并维护一个段表
- 段表和页表的表项分别类似虚拟段式、虚拟页式
	- 段表表项中的段起始地址是该段的页表起始地址


#### 逻辑地址
- 段号、页号、页内偏移
- 页对程序员是不可见的，逻辑地址（n，p，d）中，程序员可见的是段号n以及由p和d构成的段内偏移，页号p以及页内偏移d对程序透明。

#### 工作原理（36）

#### 共享和保护

##### 共享

##### 环保护
\- 
	- 内核模式
	- 执行模式
	- 管理模式
	- 用户模式
- 程序只能访问同层或者外层的数据
- 可以调用同层或者内层的服务

## 第十二周

### 操作系统软件
- 设计得三个基本选择问题：
	- 是否支持虚存技术
	- 是否支持页式/段式/段页式
	- 采用的算法
- 软件设计的主要问题：虚拟页式存储管理的问题
- 设计的主要目标：使缺页率最小
#### 虚拟存储管理软件的各个方面
- 调页策略：何时将页面载入内存
- 放置策略：将进程放在内存哪一个位置
- 替换策略：决定置换内存中的哪个页面
	- 最优算法OPT
	- 最近最少使用算法LRU
	- 先进先出算法FIFO
	- 时钟算法Clock
- 驻留集和工作集管理：动态调整进程物理页面数
	- 管理策略
	- 替换范围
- 清除策略：何时将已修改页面调出到外存上
- 负载控制：决定内存中同时驻留的进程数目


#### 调页策略
- 决定何时将页面载入内存
- 两种常用策略
	- 请求调页：只调入需要的页
		- 进程开始时缺页多，这样载入开销大
	- 预先调页：调入该页以及相邻的几个页
		- 提高调页I/O效率
		- 但是效率不能保证：额外装入的页面可能没用

#### 放置策略
- 要将进程放在内存哪一个位置
- 对纯段式系统重要：类似动态分区，会出现外碎片、压缩操作等等
	- 最佳适配、首先适配...
- 对纯页式和短页式没有影响。

#### 替换策略
- 决定置换内存中的哪个页面
##### 基本算法
- 最优算法（OPT）：淘汰还要最长时间才会使用的页面
	- 缺点：不可能实现
- 最近最少使用算法（LRU）：
	- 淘汰最久未使用页面
	- 性能接近最佳算法
	- 实现方法：
		- 链表方式：每次内存访问后，在链表找到对应页面，将其移到表头-\>表尾就是最久未使用的
		- 硬件计数器：每执行一条指令计数器+1，每次内存访问后，将当前计数器的值写到相应的页表表项-\> 计数器值最小的就是最久未使用的
- 先进先出算法（FIFO）
	- 淘汰内存中建立最早的页面
	- 实现方式：链表：表头就是最老的
	- 性能较差：
		- 较早调入的页往往是经常被访问的。
		- Belady现象：分配的页面越多，缺页率反而越高（经常使用的页面都被换出）
- 时钟算法（CLOCK）
	- 性能近似LRU，实现开销小
	- 实现算法
		- 环形链表
		- 每页关联一使用位（use bit）R
			- 在页首次被装入时和发生缺页后被访问时，置R为1
			- 在替换算法扫描后，置R为0
		- 当需要置换页时，从指针所在的当前位置开始扫描整个缓冲区，选择遇到的第一个使用位为0的帧进行代替

#### 驻留集和工作集管理
- 动态调整进程物理页面数
##### 概念
- 驻留集（resident set）指的是虚拟页式存储管理中给进程分配的物理页面（帧）的集合；驻留集大小即使这个集合的（帧）元素个数
##### 驻留集大小与系统效率
- 每个进程的驻留集越小，则同时驻留内存的进程就越多，CPU利用率越高
- 但是进程驻留集太小的话缺页率会高，调页开销变大
- 驻留集大小达到一定数目之后，再给他分配更多页面，缺页率不再明显下降

##### 管理策略
- 固定分配：驻留集大小固定
	- 替换页面从各自驻留集中选择
	- 各个进程的驻留集大小在进程创建时决定，可根据进程类型，或由程序员、系统管理员决定
- 可变分配
	- 根据缺页率动态调整
	- 需要OS对活动进程的行为进行评估
##### 替换范围
- 缺页发生时从内存中的哪些页面中选择替换？
	- 全局替换：内存任意非锁定页面均可以被替换
	- 局部替换：被替换的页面局限在缺页进程的驻留集

##### 管理策略和替换范围的组合： 驻留集管理组合策略
ppt 59


#### 工作集
##### 目的：
依据进程在过去的一段时间内访问的页面来调整驻留集大小

##### 定义
工作集是一个进程执行过程中某段时间内所访问的页面的集合，可用一个二元函数W(t,delta)表示：
- t：执行时刻
- delta：虚拟时间段

##### 工作集策略
- 记录一个进程的工作集变化
- 定期删除驻留集不在工作集中的页面
- 总是让驻留集包含工作集

##### 存在问题
- 工作集的过去变化未必能够预示工作集的将来
- 记录每个进程的工作集变化所要求的开销太大
- 对工作集窗口大小delta的最优值难以确定。

##### 工作集策略的接近策略
- 缺页率算法：跟踪缺页率而不是工作集的变化
	- 设置缺页率阈值，缺页率高/低于相关阈值时，增加/减少驻留集大小
	- 缺点：局部性阶段的过度期间效果不好
-  VSWS（可变间隔采样工作集）策略：通过增加采样频率解决PFF算法的缺点


#### 清除策略：决定何时将已修改页面调出到外存上
1. 请求清除：该页被置换之前才调出，把清除推迟到最后一刻
	- 调入所缺页面之前还要调出已修改页面，缺页进程的等待时间长 
	2. 预先清除：该页被置换之前就调出，因而可以成批调出多个页面
		- 若这批调出外存的页面中的多数在被置换之前还要被再次修改，则意义不大，形成不必要的开销。

#### 负载控制：决定内存中同时驻留的进程数目（多道程序系统的并发水平）
- 太少：CPU空闲时间太多
	- 太多：缺页频繁发生，导致抖动现象

##### 负载控制策略：
- 基于工作集策略的算法：如缺页率PFF
- （L=S判据）策略：让缺页的平均间隔时间（真正时间）等于每次缺页的处理时间（研究表明这时的CPU利用率最大）
	- 让外存设备保存50%的利用率，使CPU达到最高的利用率

##### 加载控制策略：基于Clock替换算法的加载控制策略
- 定义一个轮转计数，描述轮转的速率（即扫描环形页面链的速率）
- 轮转计数小-\>缺页较少，存在较多不常使用页面，可以提高负载；
- 大：并发水平过高，需要降低系统负载

第八章作业：275，复习题 8.5；8.8，8.11；习题：8.4，8.10；选做：8.15

