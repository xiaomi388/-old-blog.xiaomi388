---
layout: post
title: 第八周操作系统笔记
tags: [Learning]
---

## 第八周

### 第六章 并发性：死锁和饥饿

#### 主要内容
- 死锁的原理、预防、避免、检测
- 管理资源的策略方法
- 死锁的综合策略
- 哲学家的就餐问题
- 主流操作系统的并发机制

#### 死锁原理
- 十字路口模型（大家都想获得资源，但是大家想要的资源都在对方手上）

##### 联合进程图
- 记录进程共享资源的历史和分析死锁的工具
- 四种区域 P185
	- 安全区域（白色）
	- 敏感区域
	- 死锁区域（棕色）
	- 不可到达区域（彩色）
#### 可重用资源

##### 资源分类
- 可重用资源、可消费资源
- 可剥夺资源、不可剥夺资源
- 永久性资源、临时性资源

##### 可重用资源

##### 可消费资源
- 可消费/消耗资源
- 数目无限制，当一个进程得到资源时，这个资源就没了
- 例如：中断、信号、消息、I/O缓冲区的消息

###### 死锁例子
P1在等待P2的信息，P2在等待P1的信息

#### 避免死锁方法
预防、避免、检测

##### 预防方案
- 一次性请求所有资源
- 抢占
- 资源排序

##### 避免方案
- 发现至少一条安全路径

##### 检测
- 周期性调用以测试死锁

#### 资源分配图
- 用有向图描述的进程死锁模型
- 表示方法见课件 6.1.3

#### 死锁定理
1. 资源分配图没有环路 -\> 系统中没有死锁。存在环路 -\> 存在死锁。
2. 每个资源类中包含一个资源实例 -\> 环路是死锁存在的充分必要条件。

#### 死锁必要条件
- 互斥
	- 资源排他，只能被一个进程占有
	- 要求者被阻塞，直到用完者释放
- 占有且等待
	- 已经占有-\>可以提出新的资源请求
	- 资源被占有，则请求阻塞，对已有资源保持不放
- 不可剥夺/抢占
	- 自己的资源在未用完时不能被剥夺

#### 环路等待条件

#### 死锁充分必要条件
- 互斥
- 占有等待
- 不可剥夺/抢占
- 循环等待（环路等待）

#### 防止死锁
1. 鸵鸟算法：对死锁视而不见
2. 预防死锁
3. 避免死锁
4. 检测死锁

#### 死锁预防
通过破坏产生死锁的四个条件中的一个或多个条件，保证不会发生死锁

##### 破坏互斥的条件
- 允许多个进程同时使用资源
- 适用条件
	- 文件允许多个进程同时读
- 缺点
	- 不适合用于绝大多数资源

##### 破坏占有等待的条件
- 禁止已拥有资源的进程申请其他资源，一开始一次性申请所有资源
- 优点
	- 简单、安全、容易实现
- 缺点
	- 进程延迟、资源浪费

##### 破坏不可剥夺
- 提出新资源不能被满足时，释放它所有已占有资源。
- OS可以剥夺一个进程的资源并重新分配
- 适用条件
	- 资源的状态可以很容易地保存和恢复(cpu)
- 缺点
	- 实现复杂、代价大、反复申请/释放资源，系统开销大。

##### 破坏环路等待条件
- 每个进程只能占有一个资源。
- 所有资源线性排队，进程申请资源必须严格按照资源序号递增的顺序

#### 死锁避免
- 在资源的动态分配中，采用策略防止系统进入不安全状态，避免死锁
- 两种方法
	- 不启动其资源请求会导致死锁的进程
	- 不允许会导致死锁的进程资源请求
- 优点
	- 比死锁预防限制少
	- 无需死锁检测中的资源剥夺和重启
- 缺点
	- 事先声明进程请求的最大资源
	- 执行顺序无同步限制
	- 分配资源数目固定
	- 占有资源时进程不能退出

##### 进程启动拒绝
- 进程-资源需求矩阵C
- 进程-资源分配矩阵A
- 系统资源总量向量R
- 系统当前可用资源向量V

##### 资源分配拒绝（银行家算法） 更优的方法
- 定义：安全状态（存在执行时序，使所有进程都能运行到结束状态）
- 不安全状态

###### 银行家算法
- 四个数据结构
	- 资源向量
	- 可用向量
	- 需求矩阵
	- 分配矩阵
- 三种情况
	- 总申请量 \> 需求 -\> 出错
	- 请求 \> 可用 -\> 挂起
	- 定义临时新状态
		- 安全：定义新状态
		- 不安全：不分配资源并挂起

#### 死锁检测
- 周期性检测是否出现了死锁
- 死锁发生时恢复

##### 检测时机
1. 资源申请时
2. 周期性

##### 检测方法
1. 单个资源：检测资源分配图中是否存在环路
2. 多个资源：类似银行家算法的安全检查

#### 恢复
- 剥夺法
- 回退法（死锁进程回退到检查点，重启所有进程）
- 杀死进程法

#### 哲学家就餐问题

##### 信号量方案A
- 五个信号量代表五把叉子
	think()
		P(fork[i])
		P(fork[i+1 mod 5])//发生死锁的点（大家都拿着左手边的叉子
		
		eat()
		V(fork[i+1 mod 5])
		V(fork[i])

##### 信号量方案B
每次只能允许四个人在桌子进餐，一人在外等待
	P(room)
	P(fork[i])
	P(fork[i+1 mod 5])

##### 管程方案
和信号量方案A相同，但是不会死锁或者饥饿（后面的进程总要等前面的进程拿完两把叉子后才能进入管程）

#### Linux内核的并发机制