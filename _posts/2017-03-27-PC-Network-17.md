---
layout: post
title: 计算机网络笔记第十七周
tags: [Learning]
---

# 第十七周

## 复习题
1. TCP建立连接几次握手，标志？
	- 三次，SYN，SYN+ACK，ACK
2. TCP两边的序号是独立的
3. TCP关闭连接几次握手，标志？发送FIN的含义？
	- 表示主机不发送数据，但是可以接受数据
4. 为什么先发送的要等2MSL？
	1. 可能还有原来的数据段在网上，不希望这些数据段干扰到后面的链接，所以需要等待这些包完全消失后再建立新的连接，否则因为前后连接的四元组完全相同，很有可能会有干扰。
5. 校验和是怎么产生的？
	- 和UDP一样，？？？？
6. TCP滑动窗口序号（数据段编号）以字节为单位
	- sendBase RecvBase 存储窗口第一个元素的序号
	- advWin为接受窗口的大小，即空闲快的大小
	- 错序到达的处理：

### TCP滑动窗口的代码实现
- 注意，接收方上层应用程序取走数据，也要发送ACK
### TCP滑动窗口出题：
给定初始序号（1999），MSS（最大数据段大小）（500），发送窗口大小（1000）= 接受窗口大小（1000）。

假设应用层有1800字节需要发送，则发送方窗口大小1000，起始序号是*2000*，数据段的大小是500字节

期待返回的ACK的序号是2500，表示2500前的帧都接受完毕。然后接收方发送空闲块大小（通知窗口）1000-500 = 500

接受到ACK后，滑动窗口起始位置（sendBase）改变为2500，第二个数据段序号是2500，发送窗口大小变成500

此时空闲块大小变成0，ACK序号3000

接受到ACK后，滑动窗口起始位置变成3000，发送窗口大小变成0，不能发送了，要等待。

### 死锁现象
含义：当窗口为0时，如果取空缓冲区之后发送的确认丢失，就会发生死锁。

解决方法：如果发送方有数据，且窗口为0的时候，发送方启动定时器，直到发送方收到一个窗口不为0的ACK为止。如果超时了，则可能出现两种情况：1.接收方的确还是满了 2.接受丢失；因此，超时之后，发送方定期发一个字节的查询包，直到接收方发送改变窗口大小的ACK为止。

### 快速重传
- 如果发送方收到一个数据段的3次重复的ACK，它就认为该ACK其后的那一个的数据段已经丢失
- 快速重传：在超时定时到期之前重传该数据帧。

### 延迟确认
- 接收方不会立刻确认，而是延迟一段时间再确认。如果这个期间受到多个数据段，则只需要发送一个确认。这样可以将多个收到的包整合成一个ACK。

### 选择性确认
允许接收把收到的数据块通过数据段的选项告知发送方，使发送方不会重传这些数据块

### TCP超时计算
- 初始公式：估计往返时间 = （1-a）以往估计往返时间 + a样本往返时间
- Jacobson算法
- Karn算法

### 拥塞问题
- 太多主机发送太快太多数据给网络处理，这不同于流控制
- 什么是流控制？
	- 发送方数据少发一些，使得接收方可以处理得过来
	- 使用发送窗口大小来进行流控制

### TCP拥塞控制的方法
1. 。。。

### 三个问题
- 长肥管道
- 死锁问题
- 傻瓜窗口症候
	- 情形1
		- 立即发送一个数据段，即使只有一个字节
		- 只有收到上一个数据段的确认或者发送缓冲区中数据超过MSS，才可以发送下一个数据段
		- 对于即时性要求高的地方不适用。
	- 情形2
		- 等到空心块大小为接受缓冲区大小一半或达到MSS时才确认

### TCP定时器
- 重传定时器
- 持续定时器
- 保活定时器
- TIME_WAIT_