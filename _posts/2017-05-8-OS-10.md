---
layout: post
title: 第十章操作系统笔记
tags: [Learning]
---
# 第十章 多处理器调度和实时调度
- 多处理器调度
- 实时调度
- 操作系统调度例


# 第四部分 调度
- 单处理器调度
- 多处理器和实时调度



## 多处理器调度

### 多处理器系统分类
1. 松耦合、分布式多处理器、机群：每个处理器有自己的内存和I/O通道（16章）
2. 专门功能处理器：如I/O处理器，为主处理器提供服务
3. 紧耦合多处理器：一系列共享内存处理器组成（如多核）（本章讨论）

### 粒度
- 系统中进程间的同步粒度（同步率）可用于刻画多处理器和其他架构的比较
- 根据粒度不同划分5类并行度
	- 无约束并行性:进程相互独立
	- 非常粗粒度并行性：非常粗的级别存在同步
	- 粗粒度并行性：在粗的级别上存在同步
	- 中等粒度并行性：进程中的一组线程，需要高度的合作与交互
	- 细粒度并行性：线程内的并行，非常复杂

---
粒度大小: 说明: 同步间隔
细: 单指令流中固有的并行: \<20
中等: 单独应用中的并行和多任务处理: 20\~200
粗: 并发进程的多处理: 200\~2000
非常粗: 网络节点上的分布式处理: 2000\~1M
无约束: 无关进程: 不适用
---

### 设计问题
#### 把进程分配到处理器
- 对称多处理器调度：处理器-\>资源池，把进程分配到处理器
- 静态分配：一个进程从激活到完成，一直分配给同一个处理器
- 动态分配：使用全局公共队列，在一个进程的生命周期中，不同的时间可在不同的处理器上执行。
- 动态负载平衡：线程可在各个处理器的短程队列间转移

#### 单处理器上使用多道程序设计
对运行在多个处理器的系统中的中等粒度应用程序，让每个处理器繁忙不是主要目标，更重要的是*关注如何为应用程序提供最好的平衡性能*

#### 进程的实际分派
使用优先级和复杂高级调度算法，对多处理器可能会起到相反的效果

### 进程调度
- 多处理器系统中，调度原则和算法没有意义，提升空间不大，FCFS就足够了
- 多处理器系统可视为一种多服务器排队结构

### 线程调度
- 多处理器系统中，线程可用于开发应用程序真正并行性，使得线程的全部能力可以的到更好的展现
- 多处理器线程调度和处理器分配的主要方案
	- 负载共享8
	- 组调度
	- 专用处理器分配
	- 动态调度

#### 负载共享：最简单，可从单处理器直接移植，目前使用最多
优点：
- 负载被均衡分布到各个处理器上
- 不需要集中调度器
- 可使用单处理器的各种调度算法

缺点：
- 处理器多时，互斥访问内存出现瓶颈
- 被抢占的线程可能在另一个处理器上回复执行，处理器的本地高速缓存效率低
- 线程池中不区分进程，同一进程的所有线程不可能同时获得处理器的使用权，这对需要高度合作的线程，所涉及的进程切换会严重影响性能

#### 组调度
- 优点
	- 紧密相关的进程并行执行时，同步阻塞减小，进程切换很少，性能提高
	- 调度开销减少，一个决策影响许多处理器和进程
- 用于同时调度组成一个进程的一组线程
- 对中等和细粒度的并行应用程序非常必要，可避免性能的严重下降
- （已被广泛认同）

#### 专用处理器分配
- 组调度的一种极端形式
- 应用程序每个线程分配给一个处理器。
- 属于单道程序设计
- 可行原理：
	- 在有众多处理器的高度并行系统中，每个处理器只占系统总代价的一小部分
	- 避免进程切换可加快程序的运行速度

#### 多处理器调度问题和内存分配问题的关系
- 给定时刻给一个程序分配多少个处理器 —— 给定时刻给一个进程分配多少页帧
- 存在类似的处理器抖动和处理器碎片的问题（有少量几个处理器一直没被用到），可使用组调度或者专用处理器分配来避免

#### 动态调度
- 应用程序可能允许动态改变进程中的线程数目
- 操作系统只负责把处理器分配给作业，由作业负责将其的一部分可运行的任务映射到线程，并使用当前划分给它的处理器来执行这些任务

##### 动态调度算法
- 当一个作业请求若干个处理器时：
	- 若有足够的空闲处理器，则满足请求
	- 否则，若发请求的作业是新到达的，则从已经分配了多个处理器的作业中分出一个处理器给该作业
	- 若得不到满足，则保持未完成状态，直到有一个处理器变成空闲可用
- 当释放了若干处理器时：
	- 为这些处理器扫描当前未得到满足的请求队列，给表中当期那还没有处理器的作业分配一个处理器
	- 再次扫描该表，按FCFS原则分配剩下的处理器

## 实时调度
- 实时系统应用举例：机器人、自动驾驶
- 实时计算——不仅看结果，还依赖于产生结果的时间
- 实时任务具有一定的紧急程度

### 实时任务
 - 有时间期限。
- 任务分类
	- 硬实时任务：必须满足最后期限
	- 软实时任务：希望满足最后期限的要求

### 实时操作系统的要求？
- 可确定性
- 可响应性
- 用户控制
- 可靠性：系统的故障、性能损失降低都会产生灾难性后果
- 故障弱化操作

### 核心：短程任务调度
- 最重要的是保证所有硬实时任务能够在最后期限内完成，尽可能多的使软实时任务也可在他们的最后期限内完成
- 大多数现在的实时系统都不能直接处理最后期限，而是实际成尽可能地对实时任务作出响应，常常采用立即抢占方式。

### 限期调度
- 尽可能快地启动实时任务，强调快速中断处理和任务分派
- 实时调度依赖任务的额外信息
- - 就绪时间
	- DDL
	- 处理时间
	- 资源需求
	- 优先级
	- 子任务结构

### 速率单调调度(Rate Monotonic Scheduling)
- 针对周期性任务
- 速率（频率）越高 -\> 优先级越高
- 最短任务具有最高优先级
- 优势
	- 性能差别少，利用率90%
	\- 
### 优先级反转
- 举例：A的优先级高，B低，但 A 被 B 阻塞。
- 当系统环境迫使较高优先级任务等待较低优先级任务时，优先级反转发生

## Linux调度

### 非实时调度
- 对对称多处理器使用单个队列，一个任务可以调度到任何一个处理器上运行，有利于负载均衡，不利于高速缓存
- 使用一个运行队列锁，单个处理器选择任务执行的动作，会阻止其他处理器从该队列中调度任务
- 采用*非抢占*的调度策略，高优先级的任务必须等待低优先级的任务结束才能执行。

### O(1)调度策略

## Windows调度
- 具有灵活优先级系统的抢占式调度程序，基于线程优先级进行动态改变。
- 调度单位是线程不是进程
- 优先级分成两类：实时的和可变的

作业：