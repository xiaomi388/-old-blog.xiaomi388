---
layout: post
title: 第六周和第七周操作系统笔记
tags: [Learning]
---
## 第六周 上

### 并发的相关概念
- 临界资源：一次仅允许一个进程使用的资源称为临界资源。
- 临界区：访问临界资源的那部分代码
- 死锁、互斥、饥饿

### 并发的基本特征
- 并发：同时发生的进程或线程，交替共享相同资源
- 异步性：相对执行速度不可预测是多道程序系统的基本特性
- 影响进程执行速度的因素
	- 其他进程的活动
	- OS处理中断的方式
	- OS的调度策略
- 存在的问题
	- 全局资源共享存在危险
	- OS对资源分配难以达到最优
	- 调试程序设计错误非常困难

### 竞争条件
- 在并发环境中发生
- 多个进程共享数据
- 多个进程读取且至少一个进程写入
- 共享数据的最终结果取决于OS的调度策略

### OS考虑问题
- 跟踪每个进程
- 为进程分配回收资源
- 保护进程数据和物理资源
- 保证进程结果与执行速度无关（逻辑上无错误）-\> 反例：单次运行无问题，多次则有。

### 进程间的相互作用

##### 间接作用
- 共享 -\> 竞争
- 共享 -\> 合作

##### 直接作用
- 通过

### 进程间的竞争现象

##### 特点
- 独立设计进程不知道其他进程存在
- 需要访问相同资源(I/O设备，存储器、CPU、时钟等）
- 进程之间没有信息交换的要求

##### 相互间产生的影响
- 执行结果不受影响
- 执行时间受影响

##### 竞争引发的控制问题
- 互斥(mutual exclusion)

	> 多个进程需要访问一个不可共享的资源时，任何时候只能有一个访问这个资源

- 死锁(deadlock)

	> 进程A、B都在等待对方手上的资源才能进行下一步，因此一直阻塞

- 饥饿(starvation)

	> 进程A、B一直在交替使用某个资源，进程C一直在等待，没有得到资源的控制权

### 进程间通过共享合作

##### 特点
-  意识不到其他进程的存在，但是要维护数据的完整性

	> 不能同时读写同一文件

- 共享变量、文件和数据库

##### 相互间产生的影响
- 执行结果可能会受到影响
- 执行时间受影响

##### 共享引发的控制问题
- 互斥、死锁、饥饿、数据的一致性

### 进程间通过通信的合作

##### 特点
- 进程直接指导合作伙伴
- 采用信息传送的方式通信

##### 相互间产生的影响
- 同上

##### 引发的问题
- 死锁、饥饿

### 互斥的要求
- 一次只能允许一个进程进入临界区（强制排它）
- 在非临界区停止的进程必须不干涉其他进程
- 空闲让进
- 决不允许饥饿的出现
- 满足异步（相关进程的执行速度和处理机数目美欧要求限制）
- 让权等待（当进程不能进入临界区时，必须立刻释放资源？）

### 实现互斥的方法

#### 软件方法
- Deskker算法、Peterson算法

##### 第一种尝试方法：turn序轮流
- 可以保证互斥
- 硬性规定进入顺序
- 问题
	- 忙等待、必须轮流进入临界区、如果一个进程失败，另一个永远被阻塞。

##### 第二种方案：用 flag[i] 标志进程 i 进入临界区

	while(flag[1])
	    donothing();
	flag[0] = true;
	dosth();
	flag[0] = false;

- 问题
	- 一个进程在临界区内失败，另一进程永远阻塞
	- *不能保证互斥* 为什么？

##### 第三种方案：将flag[i]标志的设置提前到循环等待之前

	flag[0] = true
	while(flag[1])
	    donothing();
	dosth();
	flag[0] = false;

- 问题
	- 可能导致死锁，因为两个程序都坚持进入

##### 第四种方案：在循环等待中用延时给其他进程进入的机会

	flag[0] = true
	while(flag[1])
	    flag[0] = false;
	    //delay
	    flag[0] = true;
	dosth();
	flag[0] = false;

- 问题
	- 活锁：本来可以进入临界区，但是都进入不了

##### Dekker算法
- 全局数组 flag 表示互斥进程位置
- 全局变量 turn 解决发生的冲突
- 避免无原则的礼让
- 规定各个进程进入临界区的顺序

	boolenan flag[2]
	int turn;
	void p0(){
		while(true){
		    flag[0] = true;
		    turn = 1;
	......

###### Peterson算法
- flag 和 turn 同 Dekker

#### 硬件方法：关中断

##### 中断禁用原理
- 单 CPU 体系结构
- 如果进程访问临界资源时不被中断，就能保证互斥访问

##### 实现途径
- 使用关/开中断指令
- x86: STI/CLI

##### 缺点
- 限制了处理器交替执行各个进程的能力
- 不能用于多处理器结构

##### OS 程序语言的支持

## 第六周 下

#### 硬件方法：专用指令

##### 适用范围
- 多处理器

##### 比较和交换指令

- 一个指令周期内完成，不会被中断
- 作用：比较与test是否相等，若相等，则赋新值，且一定返回旧值。
- 实际作用：
		if(compare_and_swap(bolt,0,1) == 0)
		    临界代码

##### TestSet指令
- 比较并交换的 bool 特例，比较旧值是否为0，若是则置1后返回真，若否则置1后返回假
- 只有测试 bolt == 0 的进程才能进入临界区，并将 bolt 置为1。

##### exchange指令
- 把寄存器内容和内存内容进行交换
- 把Keyi 与 bolt 进行交换，然后判断 keyi 是否为0，若是则执行临界代码，若否则一直等待。
- 本质： keyi求和 + bolt = n

##### 指令方法优缺点：

优点：
- 支持多核多处理器
- 简单容易证明
- 可使用多个变量支持多个临界区

缺点：
- 忙等待/自旋等待
- 饥饿
- 死锁

#### 信号量
- 多个进程可以传递信号进行合作，迫使进程在某指定位置停住，直到它收到特定信号
- 可以满足任何复杂合作要求
- 信号量的值：表示可用资源数目

##### 信号量组成
- 一个整数变量，三个专门操作
	- semaphore 的结构组成
	- 初始化 
		- 初始化为非负整数（可用资源数）
	- P（测试/通过）semWait(semaphore s) P(semaphore s)
		- 信号量-1
		- 若信号量\<0，则执行P操作的进程被阻塞
	- V（增量/释放）semSignal(semaphore s) V(semaphore s)
		- 信号量+1
		- 如果信号量\<=0，则使因执行P操作被阻塞的进程接触阻塞

##### 二元信号量
- 取值 0 1
- 和一般信号量表达能力相同
- count不能小于0 得用另外方法判断等待队列是否空

##### 强信号量与弱信号量

强信号量：排队
- FIFO
- 不会饥饿

弱信号量：有优先级
- 不能保证不会饥饿

##### 信号量的实际含义
- s.count的初值
	- 系统中某类资源的数目，应该\>=0
- s.count
	- 大于等于0：可用的资源数/可以执行P(s)而不会被阻塞的进程数
	- 小于0：在等待的进程数

- P/semWait操作
- V/semSignal操作

##### 信号量的 TestSet 指令实现方案

##### 信号量的关中断实现方案

##### 信号量优缺点

优点
- 简单、表达能力强
- 解决多种类型的同步、互斥问题

缺点
- 不够安全，PV操作使用不当会产生死锁
- 遇到复杂同步互斥问题实现复杂

##### 应用
- 互斥
- 进程同步
- 生产者-消费者
- 写者-读者

## 第七周 下


##### 信号量实现互斥

##### 信号量实现同步

> 进程同步指系统中一些进程需要合作。
> A进程运行到某一点时要B进程为它提供消息，此时A阻塞等待消息。

- 举例2：例子：司机-售票员
	- 进程Pl将输入数据写入缓冲区B1
		- Pc读出B1数据，完成计算，把结果写入B2
		- Pp读出B2结果

举例2代码见PPT
- 设置四个信号量：empty1 full1 empty2 full2
- 初始分别为 1 0 1 0
- 写缓冲区：P(empty)写后V(full)，读则相反

???
---
: empty1: full1: empty2: full2
初始: 1: 0: 1: 0
Pl: 0: 1: 1: 0
Pc: 1: 0: 0: 1
Pp: 1: 0: 1: 0
---

##### 生产者/消费者问题

问题描述
 - 若干进程通过缓冲区交换数据
	- 一组进程不断写入
	- 另一组不断读出
	- 共享缓冲区无限/有N个
	- *任何时刻只能有一个进程可对共享缓冲区进行操作*
###### 无限缓冲区解决方案

- 解决方案1：二元信号量解决方案
	- 信号s：用作互斥( semWaitB(s) semSignalB(s) )
	- 信号delay：用作等待缓存区空时生产者生产( semWaitB(delay) semSignalB(delay) )
	- 存在漏洞：超前消费(n = -1)

- 改进方案：将n改为局部变量m
	n--
	m = n
	......
	if(m == 0)

- 改进方案2：把n作为信号量使用

###### 有限循环缓冲区解决方案
- 信号e指代空闲缓冲区数
- 信号n指代产品数
- 信号s用于互斥

###### 理发店问题：信号量或管程实现并发的经典例子

#### 管程

##### 概念
管程(monitor)是一种封装同步机制和同步策略的*程序设计语言结构*

##### 特点
- 封装
- 进程通过调用管程过程进入管程
- 互斥（每次只能一个进程在执行相关管程的过程）

##### 结构
- cwait(c)、csignal(c)操作管程中的条件变量实现同步
- 组成
	- 若干过程
	- 初始化序列
	- 局部数据
	- 条件变量

##### 生产者/消费者管程解决方案
- 直接调用管程过程进行生产/消费即可，代码简单(管程封装了 append() 和 take()，对读写操作进行封装)

##### 使用信号的管程：存在问题

##### 改进：使用通知和广播(cnotify)

#### 消息传递
- 消息传递自然地隐含了同步
- send(目的，消息) receive(源，信息)
- send有阻塞/非阻塞两种模式：阻塞:确保消息送达；receive也有阻塞/非阻塞两种模式
- 寻址
	- 直接寻址：给接受者进程的具体标识号
	- 间接寻址：将消息发送到共享信箱中临时保管
		- 静态方式：端口
		- 动态方式：原语 connect disconnect
- 排队规则
	- FIFO
	- 优先级
- 格式
	- 内容、长度

##### 消息传递实现互斥

##### 消息传递实现生产者-消费者问题

#### 读者-写者问题

##### 定义
同一时间只有一个写进程，多个读进程

##### 信号量实现

###### 读者优先信号量方案？
- wsem：用于读写进程互斥，读时禁止写者进入
- 信号量x用于保证 readcount 被正确更新
- 写进程可能处于饥饿状态
- 第一个进入的读者P wsem，最后一个离开的读者V wsem

###### 写者优先信号量方案？
- 保证写者优先进入，信号量 rsem 用于在写数据区时禁止读者进入
- 信号量保证writecount更新的正确性

##### 消息传递实现

###### 消息传递的写者优先方案
- 写者、读者进程发送消息给控制进程，控制进程根据当前读写情况发送信息给读写进程执行相应操作

###### 消息传递的读者优先方案

#### 例题：爱我中大
